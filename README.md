# Lern-IDApython
H·ªçc IDAPython v·ªõi ckagngoc üíÄ

## M·ª•c l·ª•c
[I. T√†i li·ªáu ƒë·ªÅ xu·∫•t](#i-t√†i-li·ªáu-h·ªçc-t·∫≠p-ƒë∆∞·ª£c-ƒë·ªÅ-xu·∫•t-cho-ida-python)
-

[II. Gi·ªõi thi·ªáu c√°c m·ª•c c∆° b·∫£n](#ii-gi·ªõi-thi·ªáu)
-

[1-c√°c-thao-t√°c-c∆°-b·∫£n](#1-c√°c-thao-t√°c-c∆°-b·∫£n)

[2-thao-t√°c-v·ªõi-segment](#2-thao-t√°c-v·ªõi-segment)

[3-thao-t√°c-v·ªõi-h√†m](#3-thao-t√°c-v·ªõi-h√†m)

[4-thao-t√°c-v·ªõi-c√¢u-l·ªánh](#4-thao-t√°c-v·ªõi-c√¢u-l·ªánh)

[5-thao-t√°c-v·ªõi-to√°n-h·∫°ng](#5-thao-t√°c-v·ªõi-to√°n-h·∫°ng)

[6-gi·∫£-l·∫≠p-ida](#6-gi·∫£-l·∫≠p-ida)

[7-thao-t√°c-v·ªõi-tham-chi·∫øu](#7-thao-t√°c-v·ªõi-tham-chi·∫øu)

---

## I. T√†i li·ªáu h·ªçc t·∫≠p ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t cho IDA python
- idaÊùÉÂ®ÅÊåáÂçóÁ¨¨‰∫åÁâà„Äã
- [https://wooyun.js.org/drops/IDAPython%20%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB%E6%9B%B4%E6%BB%8B%E6%B6%A6%20part1%20and%20part2.html](https://wooyun.js.org/drops/IDAPython ËÆ©‰Ω†ÁöÑÁîüÊ¥ªÊõ¥ÊªãÊ∂¶ part1 and part2.html)
- https://cartermgj.github.io/2017/10/10/ida-python/
- https://www.hex-rays.com/products/ida/support/idapython_docs/
-„Ääidapython book„ÄãÊúâ‰∏≠ÊñáÁâàÊú¨ÁöÑÁøªËØë
- https://bbs.pediy.com/thread-225091.htm pythonÊ®°ÊãüÊâßË°åx86ÔºåÂü∫‰∫éidapython
- „ÄäThe Beginner‚Äôs Guide to IDAPython version 6.0„Äã

## II. Gi·ªõi thi·ªáu

L√µi IDAPython c√≥ 3 module python sau:
1. **idc** Ch·ªãu tr√°ch nhi·ªám cung c·∫•p t·∫•t c·∫£ ch·ª©c nƒÉng trong IDC.
2. **idautils** cung c·∫•p c√°c h√†m ti·ªán √≠ch, nhi·ªÅu h√†m t·∫°o ra danh s√°ch
3. **idaapi** cho ph√©p ng∆∞·ªùi udngf truy c·∫≠p nhi·ªÅu d·ªØ li·ªáu c∆° b·∫£n d∆∞·ªõi d·∫°ng c√°c l·ªõp

H·∫ßu h·∫øt c√°c script vi·∫øt ra ƒë·ªÅu **import** c√°c module n√†y ngay t·ª´ ƒë·∫ßu

### 1. C√°c thao t√°c c∆° b·∫£n

Nh·∫≠n ƒë·ªãa ch·ªâ hi·ªán t·∫°i
```
idc.here()
idc.get_screen_ea()
```

L·∫•y ƒë·ªãa ch·ªâ min v√† max c·ªßa kh√¥ng gian ƒë·ªãa ch·ªâ
```
idc.get_inf_attr(idc.INF_MIN_EA)
idc.get_inf_attr(idc.INF_MAX_EA)
```

V√≠ d·ª• trong IDA c√≥ c√¢u l·ªánh sau
```
.text:00012529 mov esi, [esp+4+arg_0]
```
Ta c√≥ th·ªÉ l·∫•y c√°c th√¥ng tin nh∆∞ sau:
```
Python> idc.get_segm_name(here())
'.text'

Python> idc.GetDisasm(here())
'call    sub_405060'

Python>idc.print_insn_mnem(here())
'call'

Python>idc.print_operand(here(),0)
'sub_405060'

Python>idc.print_operand(here(),1)
''
```

### 2. Thao t√°c v·ªõi segment

L·∫∑p qua c√°c segments
```
import idc
import idaapi
import idautils

for seg in idautils.Segments():
    print(idc.get_segm_name(seg), idc.g·∫ª_segm_start(seg), idc.get_segm_end(seg))
```

### 3. Thao t√°c v·ªõi h√†m

L·∫∑p qua t·∫•t c·∫£ c√°c h√†m
```
for func in idautils.Functions():
    print(func, idc.get_func_name(func))
```

- **Functions()** s·∫Ω tr·∫£ v·ªÅ ƒë·ªãa ch·ªâ ƒë·∫ßu ti√™n c·ªßa m·ªôt h√†m ƒë√£ bi·∫øt. H√†m n√†y c≈©ng ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ t√¨m ƒë·ªãa ch·ªâ c√°c h√†m trong danh s√°ch ƒë∆∞·ª£c hcir ƒë·ªãnh.
- **get_func_name(ea)** ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l·∫•y t√™n h√†m, tham s·ªë ea c√≥ th·ªÉ l√† b·∫•t c·ª© ƒë·ªãa ch·ªâ n√†o trong h√†m
- **idaapi.get_func_qty()** l·∫•y s·ªë l∆∞·ª£ng h√†m ƒë√£ nh·∫≠n d·∫°ng ƒë∆∞·ª£c
- **idaapi.get_func(1)** l·∫•y ƒë·ªëi t∆∞·ª£ng func_t c·ªßa h√†m ƒë·∫ßu ti√™n

L·∫•y th√¥ng tin gi·ªõi h·∫°n c·ªßa m·ªôt h√†m
```
Python>idaapi.get_func(here())
<ida_funcs.func_t; proxy of <Swig Object of type 'func_t *' at 0x000001711FC33C00> >
Python>idaapi.get_func(here()).start_ea
0x40573c
Python>idaapi.get_func(here()).end_ea
0x405918
```

B√™n c·∫°nh ƒë√≥ c√≥ th·ªÉ s·ª≠ d·ª•ng h√†m **idc.get_next_func(ea)** v√† **idc.get_prev_func(ea)** ƒë·ªÉ l·∫•y func_t c·ªßa h√†m tr∆∞·ªõc v√† sau ƒë·ªãa ch·ªâ ea. Gi√° tr·ªã c·ªßa ea c·∫ßn ph·∫£i n·∫±m trong gi√° tr·ªã c·ªßa 1 h√†m nh·∫•t ƒë·ªãnh ƒëang ƒë∆∞·ª£c ph√¢n t√≠ch. M√£ kh√¥ng ƒë∆∞·ª£c ƒë√°nh d·∫•u l√† h√†m s·∫Ω c√≥ ch·ªØ ƒë·ªè, l√∫c n√†y ta c·∫ßn s·ª≠a th·ªß c√¥ng.
C√≥ th·ªÉ s·ª≠ d·ª•ng c√°c api sau ƒë·ªÉ l·∫•y start v√† end c·ªßa h√†m 
```
# L·∫•y start ea c·ªßa h√†m
ea = idc.get_func_attr(idc.here(), idc.FUNCATTR_START)
# L·∫•y end c·ªßa h√†m
ea = idc.get_func_attr(idc.here(), idc.FUNCATTR_END)

# C√°c tham s·ªë c·ªßa h√†m get_func_attr() c√≥ c√°c gi√° tr·ªã nh∆∞ d∆∞·ªõi ƒë√¢y
FUNCATTR_START = 0          # ƒë·ªãa ch·ªâ b·∫Øt ƒë·∫ßu h√†m
FUNCATTR_END = 4            # ƒë·ªãa ch·ªâ k·∫øt th√∫c h√†m
FUNCATTR_FLAGS = 8          # gi√° tr·ªã c·ªù c·ªßa h√†m
FUNCATTR_FRAME = 10         # id khung stack c·ªßa h√†m
FUNCATTR_FRSIZE = 14        # k√≠ch th∆∞·ªõc bi·∫øn c·ª•c b·ªô
FUNCATTR_FRREGS = 18        # k√≠ch th∆∞·ªõc v√πng thanh ghi ƒë√£ l∆∞u
FUNCATTR_ARGSIZE = 20       # s·ªë l∆∞·ª£ng bytes ƒë∆∞·ª£c x√≥a kh·ªèi stack
FUNCATTR_FPD = 24           # con tr·ªè khung delta
FUNCATTR_COLOR = 28         # m√£ m√†u h√†m
FUNCATTR_OWNER = 10         # chunk owner
FUNCATTR_REFQTY = 14        # s·ªë l∆∞·ª£ng chunk cha

# L·∫•y ƒë·ªãa ch·ªâ h√†m n·∫øu c√≥ t√™n c·ªßa n√≥
idc.get_name_ea_simple("<t√™n h√†m>")
```

ƒê·ªÉ duy·ªát t·∫•t c·∫£ c√¢u l·ªánh c·ªßa 1 h√†m s·ª≠ d·ª•ng code sau
```
import idc
import idaapi
import idautils

start = idc.get_func_attr(idc.here(), idc.FUNCATTR_START)
end = idc.get_func_attr(idc.here(), idc.FUNCATTR_END)

curr_addr = start

while curr_addr <= end:
    print(hex(curr_addr), idc.GetDisasm(curr_addr))
    curr_addr = idc.next_head(curr_addr, end)
```

H√†m **idc.next_head(curr_addr, end)** s·∫Ω tr·∫£ v·ªÅ ƒë·ªãa ch·ªâ ƒë·∫ßu ti√™n c·ªßa l·ªánh ti·∫øp theo gi·ªØa curr_addr v√† end ho·∫∑c n·∫øu kh√¥ng c√≥ l·ªánh n√†o s·∫Ω tr·∫£ v·ªÅ idc.BADADDR, ng∆∞·ª£c v·ªõi n√≥ l√† h√†m **idc.prev_head(curr_addr, end)**. C√°ch duy·ªát c√¢u l·ªánh n√†y ch·ªâ √°p d·ª•ng ƒë·ªëi v·ªõi c√°c h√†m ch·ªâ c√≥ c√°c c√¢u l·ªánh n·∫±m gi·ªØa start v√† end n√™n n·∫øu trong h√†m c√≥ m·ªôt l·ªánh **jmp** nh·∫£y sang v·ªã tr√≠ kh√°c b√™n ngo√†i sau ƒë√≥ quay l·∫°i ƒë·ªãa ch·ªâ gi·ªØa start v√† end th√¨ khi duy·ªát s·∫Ω b·ªã s√≥t c√¢u l·ªánh.
ƒê·ªÉ duy·ªát ƒë·∫ßy d·ªß c√°c th√†nh ph·∫ßn c·ªßa h√†m ta c√≥ th·ªÉ s·ª≠ d·ª•ng idautils.FuncItems(ea) ƒë·ªÉ l·∫∑p c√°c h∆∞·ªõng d·∫´n trong h√†m c·ª• th·ªÉ ·ªü ph·∫ßn d∆∞·ªõi.

ƒê·ªÉ l·∫•y c·ªù c·ªßa h√†m c√≥ th·ªÉ s·ª≠ d·ª•ng ƒëo·∫°n m√£ sau

```
import idc
import idaapi
import idautils

for func in idautils.Functions():
    flags = idc.get_func_attr(func. idc.FUNCATTR_FLAGS)
    if flags & FUNC_NORET:
        print(hex(func), "FUNC_NORET")
    if flags & FUNC_FAR:
        print(hex(func), "FUNC_FAR")
    if flags & FUNC_USERFAR:
        print(hex(func), "FUNC_USERFAR")
    if flags & FUNC_LIB:
        print(hex(func), "FUNC_LIB")
    if flags & FUNC_FRAME:
        print(hex(func), "FUNC_FRAME")
    if flags & FUNC_BOTTOMBP:
        print(hex(func), "FUNC_BOTTOMBP")
    if flags & FUNC_HIDDEN:
        print(hex(func), "FUNC_HIDDEN")
    if flags & FUNC_THUNK:
        print(hex(func), "FUNC_THUNK")
```

√ù nghƒ©a c√°c c·ªù c·ªßa h√†m
```
FUNC_NORET: C·ªù n√†y cho bi·∫øt h√†m c√≥ gi√° tr·ªã tr·∫£ v·ªÅ hay kh√¥ng. Gi√° tr·ªã c·ªßa n√≥ l√† 1. Sau ƒë√¢y l√† h√†m kh√¥ng c√≥ gi√° tr·ªã tr·∫£ v·ªÅ. 
L∆∞u √Ω r·∫±ng ph·∫ßn cu·ªëi c·ªßa h√†m kh√¥ng c√≥ gi√° tr·ªã tr·∫£ v·ªÅ kh√¥ng ph·∫£i l√† l·ªánh ret ho·∫∑c left.

FUNC_FAR: C·ªù n√†y r·∫•t hi·∫øm khi xu·∫•t hi·ªán v√† cho bi·∫øt ch∆∞∆°ng tr√¨nh c√≥ s·ª≠ d·ª•ng b·ªô nh·ªõ ƒë∆∞·ª£c ph√¢n ƒëo·∫°n hay kh√¥ng .

FUNC_USERFAR: C·ªù n√†y c≈©ng r·∫•t hi·∫øm v√† hi·∫øm khi ƒë∆∞·ª£c ghi l·∫°i. HexRays m√¥ t·∫£ n√≥ l√† "ng∆∞·ªùi d√πng ƒë√£ ch·ªâ ƒë·ªãnh ƒë·ªô s√¢u 
c·ªßa h√†m" v√† gi√° tr·ªã c·ªßa n√≥ l√† 32.

FUNC_LIB: M√£ n√†y th·ªÉ hi·ªán m√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ t√¨m c√°c h√†m th∆∞ vi·ªán. Vi·ªác x√°c ƒë·ªãnh m√£ h√†m th∆∞ vi·ªán l√† r·∫•t c·∫ßn thi·∫øt v√¨ ch√∫ng ta 
th∆∞·ªùng b·ªè qua n√≥ trong qu√° tr√¨nh ph√¢n t√≠ch v√† gi√° tr·ªã c·ªßa n√≥ l√† 4 . V√≠ d·ª• sau ƒë√¢y cho th·∫•y c√°ch s·ª≠ d·ª•ng c·ªù n√†y.

for func in idautils.Functions():
    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)

    if flags & FUNC_LIB:
        print(hex(func), "FUNC_LIB",get_func_name(func))

FUNC_FRAME: C·ªù n√†y cho bi·∫øt h√†m c√≥ s·ª≠ d·ª•ng thanh ghi ebp (con tr·ªè khung) hay kh√¥ng. C√°c h√†m s·ª≠ d·ª•ng thanh ghi ebp th∆∞·ªùng c√≥ c√°c c√†i ƒë·∫∑t c√∫ ph√°p 
sau ƒë·ªÉ l∆∞u khung ngƒÉn x·∫øp.

.text:00404C90                 push    ebp
.text:00404C91                 mov     ebp, esp
.text:00404C96                 sub     esp, 65Ch

FUNC_BOTTOMBP: Gi·ªëng nh∆∞ FUNC_FRAME, c·ªù n√†y ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ theo d√µi con tr·ªè khung (ebp). Ch·ª©c nƒÉng c·ªßa n√≥ l√† x√°c ƒë·ªãnh xem con tr·ªè khung trong h√†m c√≥ b·∫±ng con tr·ªè ngƒÉn x·∫øp (ƒë·∫∑c bi·ªát) 
hay kh√¥ng .

FUNC_HIDDEN: C√°c h√†m c√≥ c·ªù FUNC_HIDDEN c√≥ nghƒ©a l√† ch√∫ng b·ªã ·∫©n v√† h√†m c·∫ßn ƒë∆∞·ª£c m·ªü r·ªông ƒë·ªÉ xem ƒë∆∞·ª£c. 
N·∫øu ch√∫ng ta chuy·ªÉn ƒë·∫øn m·ªôt ƒë·ªãa ch·ªâ ƒë∆∞·ª£c ƒë√°nh d·∫•u ·∫®N, ƒë·ªãa ch·ªâ ƒë√≥ s·∫Ω t·ª± ƒë·ªông m·ªü r·ªông.

FUNC_THUNK: Cho bi·∫øt h√†m n√†y c√≥ ph·∫£i l√† h√†m thunk hay kh√¥ng. H√†m thunk ƒë·∫°i di·ªán cho m·ªôt h√†m nh·∫£y ƒë∆°n gi·∫£n.

.text:1A710606 Process32Next proc near
.text:1A710606 jmp ds:__imp_Process32Next
.text:1A710606 Process32Next endp

L∆∞u √Ω r·∫±ng m·ªôt h√†m c√≥ th·ªÉ c√≥ nhi·ªÅu t·ªï h·ª£p c·ªù.
```

### 4. Thao t√°c v·ªõi c√¢u l·ªánh

N·∫øu c√≥ ƒë·ªãa ch·ªâ c·ªßa m·ªôt h√†m c√≥ th·ªÉ duy·ªát t·∫•t c·∫£ c√¢u l·ªánh trong h√†m b·∫±ng c√°ch s·ª≠ d·ª•ng idautils.FuncItems(ea) nh∆∞ sau

```
import idc
import idautils
import idaapi

items = idautils.FuncItems(idc.here())

for item in items:
    print(hex(item), idc.GetDisasm(item))
```
#### V√≠ d·ª• nh·ªè
T√¨m t·∫•t c·∫£ c√°c l·ªánh g·ªçi ƒë·ªông <l·ªánh g·ªçi c√≥ s·ª≠ d·ª•ng operand l√† thanh ghi> ho·∫∑c l·ªánh nh·∫£y v·ªõi to√°n h·∫°ng v√† t√¥ m√†u cho l·ªánh ƒë√≥ ƒë·ªÉ d·ªÖ t√¨m ki·∫øm

```
import idc
import idautils
import idaapi

for func in idc.Functions():
    flags = idc.get_func_attr(func, idc.FUNCATTR_FLAGS)
    if flags & FUNC_LIB or flags & FUNC_THUNK:
        continue
    dism_addr = idautils.FuncItems(func)
    for line in dism_addr:
        m = idc.print_insn_mnem(line)
        if m == "call" or m == "jmp":
            op = idc.get_operand_type(line, 0)
            if op == o_reg:
                print(hex(line), idc.GetDisasm(line))
```

idc.get_operand_type(ea, n) l·∫•y lo·∫°i to√°n h·∫°ng th·ª© n, c√°c lo·∫°i to√°n h·∫°ng s·∫Ω ƒë∆∞·ª£c ƒë·ªÅ c·∫≠p ·ªü ph·∫ßn d∆∞·ªõi.
##### Note: N·∫øu mu·ªën l·∫•y ƒë·ªãa ch·ªâ ti·∫øp theo m√† kh√¥ng ph·∫£i c√¢u l·ªánh ti·∫øp theo t·ª´ ea th√¨ d√πng l·ªánh **idc.next_addr** v√† **idc.prev_addr**

### 5. Thao t√°c v·ªõi to√°n h·∫°ng

ƒê·ªÉ l·∫•y lo·∫°i to√°n h·∫°ng ta s·ª≠ d·ª•ng h√†m idc.get_operand_type(ea,n) trong ƒë√≥ ea l√† ƒë·ªãa ch·ªâ ƒë·∫ßu l·ªánh v√† n l√† ch·ªâ m·ª•c c·ªßa to√°n h·∫°ng. C√≥ c√°c lo·∫°i to√°n h·∫°ng nh∆∞ sau:

```
o_void: N·∫øu l·ªánh kh√¥ng c√≥ to√°n h·∫°ng n√†o, n√≥ s·∫Ω tr·∫£ v·ªÅ 0 . 
----------------------------------------------------
o_reg: N·∫øu to√°n h·∫°ng l√† m·ªôt thanh ghi, h√£y tr·∫£ v·ªÅ lo·∫°i n√†y, gi√° tr·ªã c·ªßa n√≥ l√† 1
----------------------------------------------------
o_mem: N·∫øu to√°n h·∫°ng l√† ƒë·ªãa ch·ªâ b·ªô nh·ªõ tr·ª±c ti·∫øp th√¨ tr·∫£ v·ªÅ lo·∫°i n√†y, gi√° tr·ªã c·ªßa n√≥ l√† 2 , lo·∫°i n√†y r·∫•t h·ªØu √≠ch cho vi·ªác t√¨m ki·∫øm 
c√°c tr√≠ch d·∫´n D·ªÆ LI·ªÜU r·∫•t h·ªØu √≠ch.

Python>print hex(ea), idc.GetDisasm(ea) 
0xa05d86 cmp ds:dword_A152B8, 0
Python>print idc.GetOpType(ea, 0) 
2
----------------------------------------------------
o_phrase: N·∫øu to√°n h·∫°ng l√† m·ªôt thao t√°c ƒë√°nh ƒë·ªãa ch·ªâ s·ª≠ d·ª•ng thanh ghi ƒë·ªãa ch·ªâ c∆° s·ªü v√† thanh ghi ch·ªâ m·ª•c th√¨ lo·∫°i n√†y ƒë∆∞·ª£c tr·∫£ v·ªÅ v√† gi√° tr·ªã l√† 3

Python>print hex(ea), idc.GetDisasm(ea) 
0x1000b8c2 mov [edi+ecx], eax 
Python>print idc.GetOpType(ea, 0) 
3
----------------------------------------------------
o_displ: N·∫øu to√°n h·∫°ng l√† m·ªôt thao t√°c ƒë√°nh ƒë·ªãa ch·ªâ s·ª≠ d·ª•ng c√°c thanh ghi v√† ph√©p d·ªãch chuy·ªÉn, th√¨ lo·∫°i n√†y ƒë∆∞·ª£c tr·∫£ v·ªÅ v√† gi√° tr·ªã l√† 4. ƒê·ªô d·ªãch chuy·ªÉn ƒë·ªÅ c·∫≠p ƒë·∫øn 0x18 nh∆∞ trong ƒëo·∫°n m√£ sau . ƒêi·ªÅu n√†y r·∫•t ph·ªï bi·∫øn khi l·∫•y d·ªØ li·ªáu nh·∫•t ƒë·ªãnh trong m·ªôt c·∫•u tr√∫c.

Python>print hex(ea), idc.GetDisasm(ea) 
0xa05dc1 mov eax, [edi+ 18h] 
Python>print idc.GetOpType(ea, 1) 
4
----------------------------------------------------
o_imm: N·∫øu to√°n h·∫°ng l√† gi√° tr·ªã x√°c ƒë·ªãnh th√¨ ki·ªÉu tr·∫£ v·ªÅ l√† 5

Python>print hex(ea), idc.GetDisasm(ea) 
0xa05da1 add esp, 0 Ch 
Python>print idc.get_operand_type(ea, 1) 
5
--------------------------------------------------- 
o_far: Ki·ªÉu tr·∫£ v·ªÅ n√†y l√† ngh·ªãch ƒë·∫£o c·ªßa x86 v√† x86_64 Kh√¥ng ph·ªï bi·∫øn. N√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ x√°c ƒë·ªãnh to√°n h·∫°ng truy c·∫≠p tr·ª±c ti·∫øp v√†o ƒë·ªãa ch·ªâ t·ª´ xa. Gi√° tr·ªã l√† 6
----------------------------------------------------
o_near: Ki·ªÉu tr·∫£ v·ªÅ n√†y kh√¥ng ph·ªï bi·∫øn trong k·ªπ thu·∫≠t ƒë·∫£o ng∆∞·ª£c x86 v√† x86_64. N√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ x√°c ƒë·ªãnh to√°n h·∫°ng truy c·∫≠p tr·ª±c ti·∫øp v√†o ƒë·ªãa ch·ªâ c·ª•c b·ªô, gi√° tr·ªã l√† 7
```

### 6. Gi·∫£ l·∫≠p IDA

ƒê·ªÉ l·∫•y c√¢u l·ªánh d·∫°ng ƒë·ªëi t∆∞·ª£ng (inst_t) t·∫°i m·ªôt ƒë·ªãa ch·ªâ ta c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh sau

```
inst = idautils.DecodeInstruction(idc.here())

# Trong ƒë√≥ ƒë·ªëi t∆∞·ª£ng inst s·∫Ω c√≥ c√°c thu·ªôc t√≠nh nh∆∞ sau
inst.itype : ƒë√¢y l√† s·ªë nguy√™n bi·ªÉu di·ªÖn lo·∫°i l·ªánh. C√°c opcode kh√°c nhau c√≥ c√πng itype v√† do ƒë√≥ opcode != itype .
inst.size : ƒë√¢y l√† k√≠ch th∆∞·ªõc c·ªßa l·ªánh ƒë∆∞·ª£c gi·∫£i m√£.
inst.Operands[] : ƒë√¢y l√† m·∫£ng b·∫Øt ƒë·∫ßu t·ª´ s·ªë 0 ch·ª©a th√¥ng tin to√°n h·∫°ng.
inst.Op1 .. OpN : ƒë√¢y l√† c√°c b√≠ danh d·ª±a tr√™n 1 trong m·∫£ng To√°n h·∫°ng .
inst.ea : ƒë·ªãa ch·ªâ tuy·∫øn t√≠nh c·ªßa l·ªánh ƒë∆∞·ª£c gi·∫£i m√£.
```

B·∫°n c√≥ th·ªÉ t·ª± h·ªèi m·ªëi quan h·ªá gi·ªØa opcode v√† itype c·ªßa n√≥ l√† g√¨ ? C√¢u tr·∫£ l·ªùi r·∫•t ƒë∆°n gi·∫£n. Trong IDA, m√¥-ƒëun b·ªô x·ª≠ l√Ω c·ªßa c∆° s·ªü d·ªØ li·ªáu m·ªü ch·ªãu tr√°ch nhi·ªám ƒëi·ªÅn v√†o tr∆∞·ªùng itype d·ª±a tr√™n opcode. Trong IDA SDK, b·∫°n c√≥ th·ªÉ t√¨m th·∫•y t·ªáp ti√™u ƒë·ªÅ c√≥ t√™n l√† **allins.hpp** . T·ªáp ti√™u ƒë·ªÅ n√†y ch·ª©a c√°c enum cho t·∫•t c·∫£ c√°c m√¥-ƒëun b·ªô x·ª≠ l√Ω ƒë∆∞·ª£c h·ªó tr·ª£ c√πng v·ªõi c√°c th√†nh vi√™n enum cho m·ªói l·ªánh ƒë∆∞·ª£c h·ªó tr·ª£:

```
// Tr√≠ch ƒëo·∫°n t·ª´ allins.hpp
// Ki·ªÉu x86/x64
li·ªát k√™
{
NN_null = 0,             // Ho·∫°t ƒë·ªông kh√¥ng x√°c ƒë·ªãnh
NN_aaa,                  // ƒêi·ªÅu ch·ªânh ASCII sau khi c·ªông
NN_aad,                  // ASCII ƒêi·ªÅu ch·ªânh AX tr∆∞·ªõc khi chia
NN_aam,                  // ASCII ƒêi·ªÅu ch·ªânh AX sau khi Nh√¢n
NN_aas,                  // ASCII ƒêi·ªÅu ch·ªânh AL sau khi tr·ª´
.
.
.
NN_jz,                   // Nh·∫£y n·∫øu b·∫±ng 0 (ZF=1)
NN_jmp,                  // Nh·∫£y
NN_jmpfi,                // Nh·∫£y xa gi√°n ti·∫øp
NN_jmpni,                // Nh·∫£y g·∫ßn gi√°n ti·∫øp
NN_jmpshort,             // Nh·∫£y ng·∫Øn (kh√¥ng s·ª≠ d·ª•ng)
NN_lahf,                 // T·∫£i c·ªù v√†o thanh ghi AH
.
.
.
// H∆∞·ªõng d·∫´n gi·∫£ Pentium III
NN_cmpeqps,              // EQ so s√°nh FP ƒë∆°n ƒë∆∞·ª£c ƒë√≥ng g√≥i
NN_cmpltps,              // ƒê√≥ng g√≥i Single-FP So s√°nh LT
NN_cmpleps,              // ƒê√≥ng g√≥i Single-FP So s√°nh LE
NN_cmpunordps,           // ƒê√≥ng g√≥i Single-FP So s√°nh UNORD
.
.
.
}
```

```
# Example
# .text:00402085 74 09 jz short loc_402090
inst = idautils.DecodeInstruction(0x402085)
print("YES" if inst.itype == idaapi.NN_jz else "NO")
```
Ng∆∞·ªùi ta c√≥ th·ªÉ ki·ªÉm tra tr·ª±c quan l·ªánh ƒë∆∞·ª£c gi·∫£i m√£ b·∫±ng c√°ch so s√°nh v·ªõi m·ªôt trong  c√°c h·∫±ng s·ªë idaapi.NN_xxxx .

ƒê·ªëi v·ªõi to√°n h·∫°ng, ng∆∞·ªùi ta c√≥ th·ªÉ truy c·∫≠p ch√∫ng th√¥ng qua inst.Operands[] ho·∫∑c inst.OpN . ƒê·ªÉ c√≥ ƒë∆∞·ª£c s·ªë to√°n h·∫°ng ƒë∆∞·ª£c l·ªánh gi·∫£i m√£ s·ª≠ d·ª•ng, b·∫°n kh√¥ng n√™n d·ª±a v√†o ƒë·ªô d√†i c·ªßa m·∫£ng Operands v√¨ n√≥ s·∫Ω lu√¥n gi·∫£i quy·∫øt th√†nh  UA_MAXOP == 8 (xem ida.hpp ). Thay v√†o ƒë√≥, h√£y l·∫∑p l·∫°i t·ª´ng to√°n h·∫°ng v√† xem lo·∫°i c·ªßa n√≥ c√≥ ph·∫£i l√† o_void hay kh√¥ng .

To√°n h·∫°ng l·ªánh ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a b·∫±ng c√°ch s·ª≠ d·ª•ng ki·ªÉu c·∫•u tr√∫c op_t ƒë∆∞·ª£c x√°c ƒë·ªãnh trong t·ªáp ti√™u ƒë·ªÅ ua.hpp .

```
op.flags : c·ªù to√°n h·∫°ng.
op.dtype : ki·ªÉu to√°n h·∫°ng. M·ªôt trong c√°c h·∫±ng s·ªë dt_xxx . Ng∆∞·ªùi ta c√≥ th·ªÉ s·ª≠ d·ª•ng tr∆∞·ªùng n√†y ƒë·ªÉ cho bi·∫øt k√≠ch th∆∞·ªõc c·ªßa to√°n h·∫°ng (1 == dt_byte , 2 == dt_word , v.v.).
op.type : ki·ªÉu to√°n h·∫°ng. M·ªôt trong c√°c h·∫±ng s·ªë o_xxx .
specflag1 .. specflag4 : c·ªù c·ª• th·ªÉ c·ªßa b·ªô x·ª≠ l√Ω.    
op.reg : thanh ghi( o_reg ).
op.phrase : thanh ghi ch·ªâ m·ª•c c√≥ ch·ª©c nƒÉng truy c·∫≠p b·ªô nh·ªõ c√°c to√°n h·∫°ng ( o_phrase ).
op.value : gi√° tr·ªã t·ª©c th·ªùi (o_imm) ho·∫∑c ƒë·ªô d·ªãch chuy·ªÉn b√™n ngo√†i ( o_displ ).
op.addr : ƒë·ªãa ch·ªâ b·ªô nh·ªõ ƒë∆∞·ª£c to√°n h·∫°ng s·ª≠ d·ª•ng ( o_mem , o_far , o_displ , o_near ).

# C√°c ki·ªÉu to√°n h·∫°ng
o_void : kh√¥ng c√≥ to√°n h·∫°ng n√†o hi·ªán di·ªán.
o_reg : to√°n h·∫°ng l√† m·ªôt thanh ghi (al, ax,es,ds‚Ä¶).
o_mem : tham chi·∫øu b·ªô nh·ªõ tr·ª±c ti·∫øp (DATA).
o_phrase : Tham chi·∫øu b·ªô nh·ªõ [Reg c∆° s·ªü + Reg ch·ªâ m·ª•c].
o_displ : b·ªô nh·ªõ Reg [Reg c∆° s·ªü + Reg ch·ªâ m·ª•c + ƒê·ªô d·ªãch chuy·ªÉn].
o_imm : gi√° tr·ªã t·ª©c th·ªùi.
o_far : ƒê·ªãa ch·ªâ xa t·ª©c th·ªùi (CODE).
o_near : ƒê·ªãa ch·ªâ g·∫ßn nh·∫•t (CODE).
o_idpspec0 ..  o_idpspec5 : c·ªù c·ª• th·ªÉ c·ªßa b·ªô x·ª≠ l√Ω.
```

Khi ki·ªÉu to√°n h·∫°ng l√† o_reg ho·∫∑c o_phrase , th√¨ c√°c gi√° tr·ªã op.reg / op.phrase ch·ª©a gi√° tr·ªã enum c·ªßa thanh ghi. Gi·ªëng nh∆∞ thu·∫≠t ng·ªØ NN_xxx , IDA SDK c≈©ng cung c·∫•p t√™n h·∫±ng s·ªë thanh ghi v√† gi√° tr·ªã c·ªßa ch√∫ng; tuy nhi√™n ƒëi·ªÅu n√†y ch·ªâ ƒë√∫ng v·ªõi m√¥-ƒëun b·ªô x·ª≠ l√Ω x86/x64. Sau ƒë√¢y l√† m·ªôt ƒëo·∫°n tr√≠ch t·ª´ t·ªáp ti√™u ƒë·ªÅ intel.hpp :

V√≠ d·ª• ph√¢n t√°ch ho√†n tianf m·ªôt l·ªánh

```
# .text:0040106F 35 90 8D 28 DA xor     eax, 0DA288D90h
out = ''
inst = idautils.DecodeInstruction(0x40106F)
out += "XOR "     if inst.itype == idaapi.NN_xor else ""
out += "EAX"      if (inst.Op1.type == idaapi.o_reg and inst.Op1.reg == 0) else ""
out += ", 0x%08X" % inst.Op2.value if (inst.Op2.type == idaapi.o_imm) else ""
print(out)
```

V√≠ d·ª• ƒë·ªÉ t√¨m m·ªôt pattern code nh∆∞ sau

```
\def scope_challenge_function(func_ea):
    f = idaapi.get_func(func_ea)
    if f is None:
        return (False, "No function at address!")
        
    emu_start, emu_end = f.startEA, f.endEA
    
    ea = emu_start
    #    
    # Find the start of the emulation pattern
    #
    stage = 0
    while ea <= emu_end:
        inst = idautils.DecodeInstruction(ea)
        if inst is None:
            return (False, "Could not decode")
            
        # Advance to next instruction
        ea += inst.size
        
        # mov (eax|edx), [ebp+?]
        if (inst.itype == idaapi.NN_mov) and (inst.Operands[0].type == idaapi.o_reg) and \
           (inst.Operands[1].type == idaapi.o_displ) and (inst.Operands[1].phrase == REG_EBP):
            # mov eax, [ebp+8]
            if (stage == 0) and (inst.Operands[0].reg == REG_EAX) and (inst.Operands[1].addr == 8):
                stage = 1
            # mov edx, [ebp+0xC]
            elif (stage == 1) and (inst.Operands[0].reg == REG_EDX) and (inst.Operands[1].addr == 0xC):
                stage = 2
                emu_start = ea
        elif (stage == 2) and (inst.itype == idaapi.NN_popa):
            # Let's decode backwards twice and double check the pattern
            ea2 = idc.PrevHead(ea)
            
            # Disassemble backwards
            for _ in range(0, 2):
                ea2 = idc.PrevHead(ea2)
                inst = idautils.DecodeInstruction(ea2)
                if (inst.itype == idaapi.NN_mov) and (inst.Op1.type == idaapi.o_displ) and \
                   (inst.Op1.reg == 5):
                    if inst.Op2.reg == 2 and stage == 2:
                        stage = 3
                    elif inst.Op2.reg == 0 and stage == 3:
                        stage = 4
                        emu_end = ea2
                        break
                   
            break
            
       
    if stage != 4:
        return (False, "Could not find markers")
            
    return (True, (emu_start, emu_end))
```

M·ªôt v√≠ d·ª• kh√°c 

```
def emulate_challenge_function(info, c1, c2, dbg = False):
    emu_start, emu_end = info
    if dbg:
        print("Emulating from %x to %x (%d, %d)" % (emu_start, emu_end, c1, c2))
    # Reset registers    
    regs = { 
      REG_EAX: c1,
      REG_EDX: c2
    }
    
    def get_opr_val(inst, regs):
        if inst.Op2.type == o_imm:
            return (True, inst.Op2.value)
        elif inst.Op2.type == idaapi.o_reg:
            return (True, regs[inst.Op2.reg])
        else:
            return (False, 0)
            
    ea = emu_start
    while ea < emu_end:
        out = ">%x: " % ea
        ok = True
        inst = idautils.DecodeInstruction(ea)
        ea += inst.size
        if inst.itype == idaapi.NN_not:
            out += "NOT"
            regs[inst.Op1.reg] = ~regs.get(inst.Op1.reg, 0) & 0xffffffff
        elif inst.itype == idaapi.NN_dec and inst.Op1.type == idaapi.o_reg:
            out += "DEC"        
            regs[inst.Op1.reg] = (regs.get(inst.Op1.reg, 0) - 1) & 0xffffffff
        elif inst.itype == idaapi.NN_inc and inst.Op1.type == idaapi.o_reg:
            out += "INC"        
            regs[inst.Op1.reg] = (regs.get(inst.Op1.reg, 0) + 1) & 0xffffffff
        elif inst.itype == idaapi.NN_xor:
            ok, val = get_opr_val(inst, regs)
            regs[inst.Op1.reg] = (regs.get(inst.Op1.reg, 0) ^ val) & 0xffffffff
            out += "XOR %08X" % val
        elif inst.itype == idaapi.NN_sub:
            ok, val = get_opr_val(inst, regs)
            regs[inst.Op1.reg] = (regs.get(inst.Op1.reg, 0) - val) & 0xffffffff
            out += "SUB %08X" % val
        elif inst.itype == idaapi.NN_add:
            ok, val = get_opr_val(inst, regs)
            regs[inst.Op1.reg] = (regs.get(inst.Op1.reg, 0) + val) & 0xffffffff
            out += "ADD %08X" % val
        else:
            ok = False
        # Dump registers
        for k, v in regs.items():
            out += (" [%s: %08X] " % (REG_NAMES.get(k, "%x" % k), v))
        if not ok:
            return (False, "Emulation failed at %08X" % ea)
        if dbg:            
            print(out)
    
    return (True, (regs[REG_EDX] << 32) | regs[REG_EAX])
```

Khi h√†m b·∫Øt ƒë·∫ßu, n√≥ s·∫Ω ƒëi·ªÅn c√°c gi√° tr·ªã ban ƒë·∫ßu c·ªßa c√°c thanh ghi v√†o t·ª´ ƒëi·ªÉn regs . Ch√∫ng ta s·ª≠ d·ª•ng op.reg l√†m kh√≥a v√†o t·ª´ ƒëi·ªÉn ƒë√≥. B·∫•t k·ª≥ thanh ghi n√†o ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o s·∫Ω ch·ª©a gi√° tr·ªã b·∫±ng kh√¥ng. Sau ƒë√≥, h√†m m√¥ ph·ªèng s·∫Ω nh·∫≠p m·ªôt v√≤ng l·∫∑p v√† gi·∫£i m√£ t·ª´ng l·ªánh. ƒê·ªëi v·ªõi m·ªói l·ªánh, n√≥ s·∫Ω ki·ªÉm tra lo·∫°i l·ªánh (ƒë·ªÉ bi·∫øt thao t√°c n√†o c·∫ßn m√¥ ph·ªèng) v√† c√°c to√°n h·∫°ng c·ªßa l·ªánh (ƒë·ªÉ bi·∫øt c√°ch l·∫•y c√°c gi√° tr·ªã c·∫ßn thi·∫øt). Khi k·∫øt th√∫c v√≤ng l·∫∑p, m·ªôt gi√° tr·ªã 64 bit s·∫Ω ƒë∆∞·ª£c tr·∫£ v·ªÅ.

Ch√∫ng ta c√≥ th·ªÉ x√°c minh xem tr√¨nh gi·∫£ l·∫≠p c√≥ ch√≠nh x√°c hay kh√¥ng b·∫±ng c√°ch so s√°nh k·∫øt qu·∫£ tr·∫£ v·ªÅ t·ª´ tr√¨nh gi·∫£ l·∫≠p v·ªõi k·∫øt qu·∫£ ch√∫ng ta ƒë√£ thu th·∫≠p tr∆∞·ªõc ƒë√≥:

```
for i in range(0, challenge_funcs_tbl_size):
    func = idc.Dword(challenge_funcs_tbl +  i * 4)
    
    ok, info = scope_challenge_function(func)
    if ok:
        ok, val = emulate_challenge_function(info, 123, 456, dbg)
        if (val != RESULTS[i]):
            print("Mistmatch #%d: %16X vs %16X" % (i, val, RESULTS[i]))
            break
        
    else:
        print("Failed to scope challenge function #%d" % i)
```

### 7. Thao t√°c v·ªõi tham chi·∫øu

Xrefs trong IDApython ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ x·ª≠ l√Ω c√°c ph√©p tham chi·∫øu v√† cross-reference (Xrefs) trong m√£ ngu·ªìn c·ªßa ch∆∞∆°ng tr√¨nh ph√¢n t√≠ch. D∆∞·ªõi ƒë√¢y l√† m·ªôt s·ªë h√†m Xrefs th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng v√† c√°ch s·ª≠ d·ª•ng:

Duy·ªát tham chi·∫øu t·ªõi m·ªôt ƒë·ªãa ch·ªâ

```
for xref in idautils.XrefsTo(ea):
    print(f"From: {hex(xref.frm)}, To: {hex(xref.to)}")

for xref in XrefsFrom(ea):
    print(f"From: {hex(xref.frm)}, To: {hex(xref.to)}")
```

L·∫•y ƒë·ªãa ch·ªâ ƒë·∫ßu ti√™n tham chi·∫øu ƒë·∫øn ea

```
cref = idc.get_first_cref_to(ea)
if cref != idaapi.BADADDR:
    print(f"First code reference to {hex(ea)} is from {hex(cref)}")
```

L·∫•y ƒë·ªãa ch·ªâ ti·∫øp theo tham chi·∫øu ƒë·∫øn ea

```
next_cref = idc.get_next_cref_to(ea, current_cref)
if next_cref != idaapi.BADADDR:
    print(f"Next code reference to {hex(ea)} is from {hex(next_cref)}")
```

L·∫•y ƒë·ªãa ch·ªâ ƒë·∫ßu ti√™n m√† ƒë·ªãa ch·ªâ ea tham chi·∫øu t·ªõi

```
cref = idc.get_first_cref_from(ea)
if cref != idaapi.BADADDR:
    print(f"First code reference from {hex(ea)} is to {hex(cref)}")

# ƒê·ªãa ch·ªâ ti·∫øp theo m√† ea tham chi·∫øu t·ªõi s·ª≠ d·ª•ng l·ªánh sau

next_cref = get_next_cref_from(ea, current_cref)
if next_cref != BADADDR:
    print(f"Next code reference from {hex(ea)} is to {hex(next_cref)}")
```
---
#### C√°c Thu·ªôc T√≠nh c·ªßa ƒê·ªëi T∆∞·ª£ng Xrefs

***from***
```
M√¥ t·∫£: ƒê·ªãa ch·ªâ (Effective Address - EA) t·ª´ ƒë√≥ tham chi·∫øu ƒë∆∞·ª£c th·ª±c hi·ªán.
Lo·∫°i: int
V√≠ d·ª•: xref.from s·∫Ω tr·∫£ v·ªÅ ƒë·ªãa ch·ªâ ngu·ªìn c·ªßa tham chi·∫øu.
```
***to***
```
M√¥ t·∫£: ƒê·ªãa ch·ªâ (EA) m√† tham chi·∫øu tr·ªè t·ªõi.
Lo·∫°i: int
V√≠ d·ª•: xref.to s·∫Ω tr·∫£ v·ªÅ ƒë·ªãa ch·ªâ ƒë√≠ch c·ªßa tham chi·∫øu.
```
***type***
```
M√¥ t·∫£: Lo·∫°i tham chi·∫øu. C√°c lo·∫°i tham chi·∫øu c√≥ th·ªÉ bao g·ªìm m√£, d·ªØ li·ªáu, nh·∫£y, g·ªçi h√†m, v√† c√°c lo·∫°i tham chi·∫øu kh√°c.
Lo·∫°i: int
V√≠ d·ª•: xref.type s·∫Ω tr·∫£ v·ªÅ ki·ªÉu tham chi·∫øu. B·∫°n c√≥ th·ªÉ so s√°nh v·ªõi c√°c h·∫±ng s·ªë nh∆∞ XREF_DATA, XREF_CODE, XREF_CALL, v.v.
```
***flags***
```
M√¥ t·∫£: C·ªù (flag) cho bi·∫øt lo·∫°i tham chi·∫øu, c√≥ th·ªÉ bao g·ªìm c√°c flag nh∆∞ XREF_DATA, XREF_CODE, XREF_JUMP, v.v.
Lo·∫°i: int
V√≠ d·ª•: xref.flags s·∫Ω tr·∫£ v·ªÅ c·ªù c·ªßa tham chi·∫øu.
```

----
#### C√°c lo·∫°i c·ªù c·ªßa ƒë·ªëi t∆∞·ª£ng xrefs
Khi l√†m vi·ªác v·ªõi c√°c h√†m Xrefs, b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng c√°c flag ƒë·ªÉ ch·ªâ ƒë·ªãnh lo·∫°i tham chi·∫øu b·∫°n quan t√¢m.

***1. XREF_DATA***
```
M√¥ t·∫£: Tham chi·∫øu d·ªØ li·ªáu (data reference).
Flag: 0x0001
```
***2. XREF_CODE***
```
M√¥ t·∫£: Tham chi·∫øu m√£ (code reference).
Flag: 0x0002
```
***3. XREF_USER***
```
M√¥ t·∫£: Tham chi·∫øu do ng∆∞·ªùi d√πng t·∫°o (user-defined reference).
Flag: 0x0004
```
***4. XREF_JUMP***
```
M√¥ t·∫£: Tham chi·∫øu nh·∫£y (jump reference).
Flag: 0x0008
```
***5. XREF_CALL***
```
M√¥ t·∫£: Tham chi·∫øu g·ªçi h√†m (call reference).
Flag: 0x0010
```
***6. XREF_DUMMY***
```
M√¥ t·∫£: Tham chi·∫øu gi·∫£ (dummy reference) ‚Äì th∆∞·ªùng kh√¥ng quan tr·ªçng trong ph√¢n t√≠ch th√¥ng th∆∞·ªùng.
Flag: 0x0020
```
***7. XREF_TYPE_MASK***
```
M√¥ t·∫£: Mask ƒë·ªÉ l·ªçc c√°c lo·∫°i tham chi·∫øu.
Flag: 0x003F
```

### 8. Debug hook v·ªõi IDApython
T·∫°o m·ªôt file Python m·ªõi ƒë·ªÉ ch·ª©a script. D∆∞·ªõi ƒë√¢y l√† v√≠ d·ª• v·ªÅ m·ªôt script ƒë∆°n gi·∫£n ƒë·ªÉ thi·∫øt l·∫≠p v√† s·ª≠ d·ª•ng debug hook.

```
import idaapi

class MyDebugHook(idaapi.DBG_Hooks):
    def __init__(self):
        super(MyDebugHook, self).__init__()
    
    def dbg_bpt(self, tid, ea):
        print(f"Breakpoint hit at address: {hex(ea)}")
        return idaapi.DBG_CONTINUE
    
    def dbg_step_into(self, tid):
        print(f"Stepped into thread: {tid}")
        return idaapi.DBG_CONTINUE

    def dbg_step_over(self, tid):
        print(f"Stepped over thread: {tid}")
        return idaapi.DBG_CONTINUE

    def dbg_step_out(self, tid):
        print(f"Stepped out of thread: {tid}")
        return idaapi.DBG_CONTINUE

    def dbg_ret(self, tid):
        print(f"Function return in thread: {tid}")
        return idaapi.DBG_CONTINUE

    def dbg_exception(self, tid, exception):
        print(f"Exception in thread {tid}: {exception}")
        return idaapi.DBG_CONTINUE

# Initialize and hook
debug_hook = MyDebugHook()
debug_hook.hook()
print("Debug hook installed")
```